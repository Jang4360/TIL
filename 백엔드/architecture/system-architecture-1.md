# 대규모 시스템 설계를 위한 핵심 개념 정리
사용자 증가에 따라 시스템이 직면하는 확장성, 안정성, 가용성 문제를 어떤 순서로 풀어가는지에 대해 정리한 문서이다. 단일 서버 구성에서 출발하여 계층 분리, 로드밸런싱, 캐시 및 CDN 도입, 상태/무상태 아키텍처 전환, 메시지 큐 기반 비동기 처리, 그리고 데이터베이스 샤딩을 통한 데이터 계층 확장까지 이어지는 흐름을 중심으로 정리한다.

---

## 1. 데이터베이스 계층 분리

사용자가 증가하면 하나의 서버로 모든 요청을 처리하는 것은 한계가 있다.  
초기에는 단일 서버 운영이 간단헤 보이지만 트래픽이 증가할 수록 웹 요청 처리(동시성, 네트워크, CPU)와 
데이터 처리(디스크 I/O, 락, 트랜잭션)의 성격이 달라 병목이 한 컴포넌트에 몰리기 쉽다.

이때 웹/모바일 트래픽을 처리하는 웹 계층과 데이터를 저장·관리하는 데이터 계층을 분리하면,  
각 계층을 서로 독립적으로 확장할 수 있다.

데이터 계층에서는 전통적인 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL) 중 하나를 선택해야 한다.  
관계형 데이터베이스는 강한 정합성을 다루는데 유리하고 SQL을 기반으로 다수의 테이블을 조인할 수 있는 반면,  
비관계형 데이터베이스는 조인 연산을 지원하지 않는 대신 확장성과 성능 측면에서 장점을 가진다.

### 비관계형 데이터베이스가 적합한 경우

- 아주 낮은 응답 지연 시간이 요구되는 경우
- 데이터 구조가 고정되지 않은 비정형 데이터인 경우
- 데이터를 단순히 직렬화/역직렬화해서 저장·조회하는 경우
- 매우 큰 데이터 집합을 저장해야 하는 경우

---

## 2. 수직적 규모 확장과 수평적 규모 확장

서버로 유입되는 트래픽이 적은 경우에는 스케일 업(수직적 규모 확장)이 단순한 해결책이 될 수 있다.  
이는 CPU, 메모리 등 서버 하드웨어 성능을 강화하는 방식이다.

그러나 스케일 업 방식에는 다음과 같은 한계가 존재한다.

- 물리적 한계: 하나의 서버에 CPU나 메모리를 무한정 증설할 수 없다.
- 논리적 한계: 서버 장애 발생 시 자동 복구가 어렵고 단일 장애 지점(SPOF)이 된다.

이로 인해 일정 규모 이상에서는 수평적 확장(scale out)이 필수적이다.

---

## 3. 로드밸런서

로드밸런서는 웹 계층을 수평 확장하기 위한 핵심 컴포넌트로
사용자 트래픽이 증가했을 때 여러 대의 서버로 요청을 분산하는 역할을 수행한다.  

사용자는 로드밸런서의 Public IP 주소로 접속하며,  
로드밸런서와 웹 서버 간 통신은 같은 네트워크 내에서 Private IP를 사용한다.

이를 통해 서버 내부 구조를 외부에 노출하지 않으면서도 트래픽 분산과 보안을 동시에 확보할 수 있다.
또한 웹 서버를 증설하거나 축소할 때 로드밸런서의 타깃 그룹에 서버를 추가/삭제하는 방식으로 운영할 수 있다.

---

## 4. 데이터베이스 다중화 (Replication)
<img width="632" height="582" alt="Image" src="https://github.com/user-attachments/assets/dab31006-8c93-4097-be6c-9f978349dc04" />
대부분의 데이터베이스 관리 시스템은 다중화를 지원한다.  
일반적으로 주(Primary, Master) 서버와 부(Replica, Slave) 서버 구조를 사용한다.

주 데이터베이스 서버는 쓰기 연산(insert, update, delete)을 담당하고  
부 데이터베이스 서버는 주 서버의 데이터를 복제받아 읽기 연산을 처리한다.

일반적인 애플리케이션에서는 읽기 연산의 비중이 쓰기보다 훨씬 높기 때문에  
부 데이터베이스의 수가 주 데이터베이스보다 많게 구성된다.

### 다중화의 장점

- 성능 향상: 읽기 요청을 여러 Replica로 분산 가능
- 안정성: 여러 서버에 데이터 사본을 유지하여 데이터 손실 위험 감소
- 가용성: 일부 서버 장애 시에도 서비스 지속 가능

### 장애 상황별 동작

- **부 서버 장애**
  - 읽기 요청을 일시적으로 주 서버로 전달하는데 이를 버틸 수 있는 여력을 고려해야 한다
  - 새로운 Replica가 장애 서버를 대체할 수 있는 자동화가 필요하다

- **주 서버 장애**
  - Replica 중 하나가 새로운 Primary로 승격한다
  - 일부 데이터가 최신 상태가 아닐 수 있어 복구 스크립트가 필요하다
  -- 다중 마스터 또는 원형 다중화 구조가 있으면 대응이 용이하다

---

## 5. 캐시

응답 시간을 줄이기 위해 캐시를 사용하고 정적 콘텐츠는 CDN으로 분리하는 것이 효과적이다.

캐시는 비용이 큰 연산 결과나 자주 조회되는 데이터를 메모리에 저장하여  
다음 요청을 빠르게 처리한다.

대표적인 전략으로 **읽기 주도형 캐시 전략(Read-Through Cache)** 가 있으며,  
요청 시 캐시를 먼저 조회하고 없을 경우 DB에서 조회 후 캐시에 저장한다.신이 하나의 트랜잭션으로 묶이지 않으면 불일치 발생 가능
- 캐시는 휘발성이 강하므로 영속 데이터 저장 용도로 부적합
- 읽기 비중이 높은 데이터에 적합
- TTL 설정이 너무 짧거나 길면 성능 또는 일관성 문제가 발생
- 단일 캐시 서버는 SPOF가 될 수 있으므로 다중화 필요
- 캐시 메모리가 작으면 잦은 데이터 방출로 성능 저하
- LRU(Least Recently Used) 정책이 가장 일반적으로 사용됨

---

## 6. 콘텐츠 전송 네트워크(CDN)

CDN은 정적 콘텐츠(이미지, CSS, JS, 비디오)를  
지리적으로 분산된 서버에서 제공하는 네트워크이다.

사용자웹사이트에 접근하면 가장 가까운 CDN 서버에서 콘텐츠를 제공하여  
지연 시간을 최소화한다.

CDN에 캐시된 데이터가 없을  원본 서버에서 데이터를 가져오며,  
응답 헤더의 TTL 값에 따라 캐시 유지 시간을 결정한.

### CDN 사용 시 고려사항

- 트래픽 비용 발생
- 시의성이 중요한 콘텐츠는 TTL 조정- 제 3 사업자가 운영하는 경우가 많아 트래픽 양에 따라 비용이 증가할 수 있다 애- 시의성이 중요한 콘텐츠는 TTL이 중요하다. TTL이 짧으면 원본 서버 요청이 많아지고, TTL이 길면 최신성이 떨어진다. 
- CDN 장애 시에는 원본 서버에서 직접 가져오도록 클라이언트를 구성하거나 장애 감지 후 우회하는 전략이 필요하다. 
- 콘텐츠 무효화는 API 기반 캐시 무효화 또는 URL에 버전을 붙이는 오브젝트 버저닝 전략을 통해 새로운 콘텐츠를 서비스 하는 방식이 있다.

---

## 7. 상태 아키텍처와 무상태 아키텍처
<img width="575" height="573" alt="Image" src="https://github.com/user-attachments/assets/8acfcd48-5015-4fe2-9d98-16ee3910de3f" />

서버가 세션 상태를 직접 보관하는 경우,  
사용자는 특정 서버에 종속되며 이를 **Sticky Session**이라 한다.

세션을 인메모리에 저장하면 서버 확장과 축소가 어려워지므로,  
세션 데이터를 DB나 Redis 같은 공유 저장소로 분리하면 무상태에 가까워진다.

### 세션과 JWT 비교

- 세션: 즉시 무효화가 중요할 때 적합
- JWT: 무상태 인증이 가능하나 즉시 무효화가 어려움

JWT는 Access Token을 Authorization 헤더로 전달하고,  
Refresh Token은 HttpOnly Cookie에 저장해 로그인 상태를 관리한다.

Access Token 만료 이전 로그아웃 문제는  
짧은 만료 시간, Refresh Token 서버 통제, Redis 추가 검증으로 완화한다.

---

## 8. 데이터 센터와 지리적 라우팅

여러 데이터 센터를 운영할 경우,  
사용자는 GeoDNS를 통해 가장 가까운 데이터 센터로 라우팅된다.

다중 데이터 센터 환경에서는 트래픽 우회, 데이터 동기화, 자동화된 배포가 필수 요소이다.

---

## 9. 메시지 큐

메시지 큐는 지금 처리하지 않아도 되는 작업을 안전하게 나중으로 넘기기 위한 기술이다.  
비동기 처리, 트래픽 완충, 장애 격리, 이벤트 기반 아키텍처 구현에 활용된다.

메시지는 큐 적재 → 소비 → ACK 순으로 처리되며,  
실패 시 재전달이 가능하다.

### 일반 MQ vs 로그 기반 큐

- 일반 MQ는 작업 처리 중심(1:1 소비)
- 로그 기반 큐는 이벤트 스트림 중심(1:N 소비, 재처리 가능)

---

## 10. 데이터베이스 규모 확장

### 수직 확장
- 비용과 장애 위험이 큼
- 근본적인 한계 존재

### 수평 확장

1. **Primary + Replica**
   - 데이터 복제를 통한 읽기 성능 및 가용성 향상
   - 쓰기 병목은 해결되지 않음

2. **샤딩**
   - 데이터를 분할하여 쓰기 성능과 저장 용량 확장
   - 진정한 데이터 차원의 수평 확장

실제 서비스에서는  
샤딩으로 데이터 분할을 수행하고,  
각 샤드 내부에서 Replica를 둔다.

---

## 11. 시스템 규모 확장을 위한 핵심 원칙
<img width="633" height="620" alt="Image" src="https://github.com/user-attachments/assets/556a71d8-2da1-4d4a-9a26-351de4fbc91b" />

1. 웹 계층 무상태화
2. 모든 계층 다중화
3. 캐시 적극 활용
4. 다중 데이터 센터 지원
5. CDN으로 정적 콘텐츠 제공
6. DB 샤딩 적용
7. 계층별 서비스 분리
8. 지속적 모니터링과 자동화

**다중화는 서버를 복제하여 장애를 대비하는 개념이며,  
샤딩은 데이터를 분할하는 개념으로 서로 다른 목적을 가진다.**
