# 대규모 시스템 설계 기초 1장

---

## 🗄️ 데이터베이스

사용자가 늘어나면 서버 하나로는 충분하지 않아 여러 대로 늘려야 한다.  
일반적으로 다음과 같이 역할을 분리한다.

- 하나는 **웹/모바일 트래픽 처리 용도**이다.
- 다른 하나는 **데이터베이스 용도**이다.

웹 계층과 데이터 계층을 분리하면 각각을 **독립적으로 확장**할 수 있다.

---

### 관계형 데이터베이스 vs 비관계형 데이터베이스

데이터베이스는 전통적인 **관계형 데이터베이스(RDBMS)** 와  
**비관계형 데이터베이스(NoSQL)** 중에서 선택한다.

- **관계형 데이터베이스**
  - SQL 문으로 여러 개의 테이블을 조인하여 합칠 수 있다.
- **비관계형 데이터베이스**
  - 조인 연산을 지원하지 않는다.

---

### 비관계형 데이터베이스가 적합한 경우

- 아주 낮은 응답 지연 시간이 요구될 때이다.
- 다루는 데이터가 비정형일 때이다.
- 데이터를 직렬화/역직렬화만 하면 될 때이다.
- 아주 많은 데이터를 저장해야 할 때이다.

---

## 수직적 규모 vs 수평적 규모 확장

서버로 들어오는 트래픽의 양이 적을 때는  
**스케일 업(수직적 규모 확장)** 방식이 단순하고 좋은 선택지가 된다.

---

### 스케일 업 방식의 한계

- **물리적 한계**: 한 대의 서버에 CPU나 메모리를 무한대로 증설 할 수 없다.
- **논리적 한계**: 장애에 대한 자동 복구 방안이 없다.

---

## 로드밸런서

로드밸런서는 사용자의 트래픽 증가로 여러 대의 서버로 부하를 분산해야 할 때 사용한다.

- 사용자는 **로드밸런서의 Public IP 주소**로 접속한다.
- 보안을 위해 서버 간 통신에는 **Private IP 주소**가 이용된다.

> Private IP는 같은 네트워크에 속한 서버 사이의 통신에만 쓰이는 주소로  
> 로드밸런서가 웹 서버와 통신하기 위해 사용된다.

---

## 데이터베이스 다중화

<img width="632" height="582" alt="Image" src="https://github.com/user-attachments/assets/dab31006-8c93-4097-be6c-9f978349dc04" />

- 정적 콘텐츠는 웹 서버가 아닌 **CDN**에서 제공하는 것이 더 나은 성능을 보장한다.
- **캐시**는 데이터베이스 부하를 줄여준다.

많은 데이터베이스 관리 시스템은 다중화를 지원한다.

- 서버 사이에 **주(master) - 부(slave)** 관계를 설정한다.
- 데이터 원본은 **주 서버**에 둔다.
- 사본은 **부 서버**에 둔다.

---

### 읽기 / 쓰기 분리

- 쓰기 연산 → **주 서버**
- 읽기 연산 → **부 서버**

> 데이터베이스 변경 명령어(insert, update, delete)는 반드시 주 데이터베이스로만 전달되어야 한다.

대부분의 애플리케이션은 **읽기 연산의 비중이 쓰기 연산보다 훨씬 높다.**

---

### 장점

- **성능 증가**
  - 읽기와 쓰기 분리로 성능이 향상된다.
- **안정성**
  - 분산된 데이터베이스로 데이터 유실을 방지한다.
- **가용성**
  - 장애 발생 시에도 서비스가 지속 가능하다.

---

### 서버 장애 상황

- **부 서버 다운**
  - 읽기 연산을 주 서버로 전달한다.
  - 즉시 장애 서버를 새로운 부 서버로 대체한다.
- **주 서버 다운**
  - 부 서버가 새로운 주 서버 역할을 수행한다.
  - 최신 데이터가 아닐 수 있어 복구 스크립트 실행이 필요하다.

> 다중 마스터, 원형 다중화 방식은 이러한 상황에 대응하는 데 도움이 된다.

---

## 캐시

응답시간은 캐시를 붙이고 정적 콘텐츠를 CDN으로 옮기면 개선할 수 있다.
캐시는 값비싼 연산 결과 혹은 자주 참조되는 데이터를 메모리에 저장해 빠르게 반환하도록 돕는다.

**읽기 주도형 캐시 전략**

1. 캐시 확인
2. 캐시에 데이터가 있으면 반환
3. 없으면 DB 조회
4. 조회 결과를 캐시에 저장 후 반환

---

### 캐시 사용 시 주의사항

- 캐시 갱신과 원본 데이터 갱신이 단일 트랜잭션이 아니면 데이터 불일치가 발생한다.
- 캐시는 휘발성이 강하므로 영속 데이터 저장에 부적합하다.
- 쓰기보다 읽기가 많은 데이터에 적합하다.
- **캐시 만료 시간**
  - 너무 짧으면 DB 부하가 증가한다.
  - 너무 길면 데이터 불일치가 발생한다.
- 캐시 서버 1대는 **SPOF** (특정 지점의 장애가 전체 시스템의 동작을 중단시키는 것)
  - 여러 지역에 분산시키는 것이 필요하다.
- 캐시 메모리는 과할당을 권장한다.
- 데이터 방출 정책은 주로 **LRU (Least Recently Used)**를 사용한다.

---

## 콘텐츠 전송 네트워크 (CDN)

CDN은 정적 콘텐츠를 전송하기 위해 지리적으로 분산된 서버의 네트워크이다.

정적 콘텐츠는
- 이미지
- 비디오
- CSS
- JavaScript 파일
가 있다.

동적 콘텐츠 캐싱은 요청 경로, 쿼리 문자열, 쿠키, 헤더 등을 기준으로 HTML을 캐싱한다.

---

### 동작 방식

- 사용자는 가장 가까운 CDN 서버에서 콘텐츠를 제공받는다.
- 캐시에 없으면 원본 서버에서 가져온다.
- 응답 헤더의 TTL 동안 캐시된다.

### CDN 사용 시 고려사항

- 제3 사업자 서비스로 비용이 발생한다.
- 시의성이 중요한 콘텐츠는 TTL 설정이 중요하다.
- 장애 발생 시 원본 서버로 직접 요청하는 구성이 필요하다.
- 콘텐츠 무효화 방법
  - CDN이 제공하는 API를 사용한다.
  - URL 버저닝을 사용해 콘텐츠의 다른 버전을 서비스한다.

---

## 상태 아키텍처

서버가 상태(세션)를 가지면 사용자는 특정 서버에 종속되며 이를 **Sticky Session**이라 부른다.

> 서버 A에 로그인하면 이후 요청도 서버 A로 가야 세션 유지가 가능하다.


### 문제점

- 로드밸런서의 부담이 증가한다.
- 서버 증설 및 축소 시 제약이 발생한다.

세션 정보를 인메모리가 아닌 DB 또는 캐시에 저장하면 Sticky Session은 사라지고 무상태에 가까워진다.

---

### 세션 vs JWT

- **세션**
  - 즉시 무효화가 중요한 시스템에 적합하다.
  - 세션 ID 기반으로 서버 저장소를 조회한다.
- **JWT**
  - 클라이언트가 토큰을 보유하기에 즉시 무효화가 어렵다.
  - blacklist, 짧은 만료, refresh 구조가 필요하다.

---

### 인증 방식 정리

- 세션 로그인
  - 세션 ID를 쿠키로 전달하고 요청마다 자동으로 전송된다.
- JWT
  - Access Token → Authorization 헤더에 포함 시킨다.
  - Refresh Token → HttpOnly Cookie에 포함 시킨다.

**JWT의 문제**

- 로그아웃해도 Access Token 만료 전까지 접속이 가능하다.

**대응 방법**
- Access Token 만료 시간을 매우 짧게한다.
- Refresh Token을 서버에서 통제한다.
- Redis로 추가 검증을 한다.

---

## 🧩 무상태 아키텍처

<img width="575" height="573" alt="Image" src="https://github.com/user-attachments/assets/8acfcd48-5015-4fe2-9d98-16ee3910de3f" />

무상태 아키텍처에서는 상태 정보가 웹 서버 외부에 존재한다.

- 서버 자동 확장이 가능하다.
- 상태는 공유 저장소에서 관리한다.

---

### 상태 저장소 예시

- 관계형 데이터베이스
- Redis / Memcached
- NoSQL

> NoSQL은 규모 확장 측면에서 특히 용이하다.
