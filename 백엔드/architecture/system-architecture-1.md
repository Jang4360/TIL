# 대규모 시스템 설계 기초 1장

## 데이터베이스

사용자가 늘면 서버 하나로는 충분하지 않아 여러대로 늘려야 한다. 
하나는 웹/모바일 트래픽 처리 용도고 다른 하나는 데이터베이스 용이다. 웹계층과 데이터 계층을 분리하면 각각을 독립적으로 확장할 수 있다.

데이터베이스는 전통적인 관계형 데이터베이스와 비관계형 데이터베이스 중에 선택을 하면 되는데
관계형 데이터베이스는 SQL문으로 여러개의 테이블을 조인하여 합칠 수 있고 비관계형 데이터베이스는 조인 연산을 지원하지 않는다는 차이가 있다.

### 비관계형 데이터베이스가 적합한 경우

- 아주 낮은 응답 지연 시간이 요구될 때
- 다루는 데이터가 비정형일 때
- 데이터를 직렬화/역직렬화만 하면 될 때
- 아주 많은 데이터를 저장해야 할 때

---

## 수직적 규모 vs 수평적 규모

서버로 들어오는 트래픽의 양이 적을 때는 스케일 업(수직적 규모 확장) 방식이 단순하고 좋은 선택지가 된다.

### 스케일 업 방식 한계

- 물리적 한계: 한 대의 서버에 cpu나 메모리를 무한대로 증설 할 수 없다.
- 논리적 한계: 장애에 대한 자동 복구 방안이 없다.

---

## 로드밸런서

로드밸런서는 사용자의 트래픽 증가로 여러대의 서버로 부하를 분산을 해야 할 때 사용한다.
사용자는 로드밸런서의 Public IP 주소로 접속하고 보안을 위해 서버 간 통신에는 Private IP 주소가 이용된다. 
이는 같은 네트워크에 속한 서버 사이의 통신에만 쓰이는 주소로, 로드밸런서가 웹 서버와 통신하기 위해 사용한다.

---

## 데이터베이스 다중화

![image.png](attachment:a8b87364-c6a6-4cbb-acbd-ec23910b2f60:image.png)
- 정적 콘텐츠는 웹서버가 아닌 CDN에서 제공하는 것이 더 나은 성능을 보장한다.
- 캐시가 데이터베이스 부하를 줄여준다.

많은 데이터베이스 관리 시스템이 다중화를 지원한다.
서버 사이에 주(master)-부(slave)관계를 설정해 데이터 원본은 주 서버에, 사본은 부 서버에 저장한다.

쓰기 연산은 주 서버에만 지원을 하고 부 서버는 주 서버로부터 그 사본을 전달받으며, 읽기 연산만을 지원한다.
데이터베이스를 변경하는 명령어들(insert, update, delete)은 주 데이터베이스로만 전달되어야 한다.

대부분의 애플리케이션은 쓰기 연산의 비중보다 읽기 연산의 비중이 높아 부 데이터베이스의 수가 주 데이터베이스의 수보다 많다는 특징이 있다.

### 장점

- 성능 증가: 쓰기와 읽기를 위한 데이터베이스를 분리하기에 읽기 성능이 향상된다.
- 안정성: 여러 대의 분산 데이터베이스를 구축하면 화재와 같은 문제가 발생하더라도 데이터가 보존된다.
- 가용성: 데이터를 여러 지역에 복제해 둠으로써 하나의 서버에서 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스 할 수 있다.

### 서버가 다운되는 경우

- 부 서버가 다운될 경우: 읽기 연산이 한시적으로 주 데이터베이스로 전달될 것이다. 또한 즉시 부 데이터베이스 서버가 장애 서버를 대체할 것이다.
- 주 서버가 다운될 경우: 부 데이터베이스 서버가 새로운 주 서버가 되고 한시적으로 모든 연산이 새로운 주 서버에서 수행될 것이다. 부 서버에 보관된 데이터가 최신 상태가 아닐 수도 있어 없는 데이터는 복구 스크립트를 돌려 추가해야 한다. (다중 마스터, 원형 다중화 방식을 도입하면 이런 상황에 대처하는데 도움이 된다)

---

## 캐시

응답시간은 캐시를 붙이고 정적 콘텐츠를 CDN(콘텐츠 전송 네트워크)로 옮기면 개선할 수 있다.

캐시는 값비싼 연산결과 혹은 자주 참조되는 데이터를 메모리 안에 두고 다음 요청이 빨리 처리될 수 있도록 도와준다.

캐시 전략 중 **읽기 주도형 캐시 전략**은 클라이언트 요청 시 캐시를 먼저 확인해 필요한 데이터가 있으면 반환하고 없다면 데이터베이스에 질의해 캐시에 저장한 후 반환한다.

이외에도 여러 캐시 전략이 존재하며 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택해야 한다.

### 캐시 사용시 주의사항

- 저장소 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는다면 데이터 불일치 문제가 발생 할 수 있다. (여러 지역에 걸쳐 확장할 경우 캐시와 저장소 사이의 일관성을 유지하는 것은 어려움)
- 휘발성이 강하기에 영속적으로 보관 할 데이터를 캐시에 두는 것은 적합하지 않다.
- 쓰기 작업보다 읽기 작업이 많은 데이터의 경우에 적합하다.
- 캐시 만료시간: 너무 빨리 만료되면 데이터베이스에 자주 접근해야해서 응답 시간이 지연되는 문제가 발생하고, 너무 길면 데이터베이스와의 불일치 문제가 발생한다.
- 캐시를 한 대만 두는 경우 해당 서버는 SPOF(단일 장애 지점)가 될 수 있다. (SPOF: 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜 버리는 것) → 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.
- 캐시 메모리: 너무 작으면 데이터가 너무 자주 캐시에서 밀려나 캐시의 성능이 떨어진다. → 캐시 메모리를 과할당하면 된다.
- 데이터 방출 정책은 캐시가 꽉 찼을 때 기존 데이터를 내보내는 정책으로 주로 LRU를 많이 사용한다 (사용 시점이 가장 오래된 데이터를 방출)

---

## 콘텐츠 전송 네트워크(CDN)

CDN은 정적 콘텐츠를 전송하는데 쓰이는 지리적으로 분산된 서버의 네트워크이다. 정적콘텐츠로 이미지, 비디오, CSS, javascript파일 등이 있다.

반면 동적 콘텐츠 캐싱은 요청 경로, 질의 문자열(Query String), 쿠키, 요청 헤더 등의 정보에 기반해 HTML페이지를 캐싱하는 것이다.

어떤 사용자가 웹사이트를 방문하게 되면 사용자와 가장 가까운 CDN서버에서 정적 콘텐츠를 제공해준다. 
캐시와 마찬가지로 데이터가 CDN 서버에 없다면 원본 서버에 데이터를 요청하는데, 이 때 응답의 헤더에는 TTL이 들어있어 TTL 시간까지 캐시를 하게된다.

### CDN 사용 시 고려해야 할 사항

- 제 3 사업자가 운영하기에 CDN 서버로 들어가고 나가는 데이터 전송 양에 따라 요금을 낸다.
- 시의성(time sensitive)이 중요한 컨텐츠의 경우엔 만료 시점을 잘 정해야 한다. 너무 짧으면 원본 서버에 자주 접속해야 해서 지연이 될 수 있고 너무 길면 콘텐츠의 신선도가 떨어질 수 있다.
- CDN에 장애가 발생했을 경우, 해당 문제를 감지해 원본 서버로부터 직접 데이터를 가져오도록 클라이언트를 구성하는 것이 필요하다.
- 콘텐츠 무효화 방법
    - CDN서비스 사업자에서 제공하는 API를 사용해서 콘텐츠를 무효화시킬 수 있다.
    - url 뒤에 버전을 명시하는 인자를 추가하는 오브젝트 버저닝을 사용해 콘텐츠의 다른 버전을 서비스함으로써 무효화시킬 수 있다.

---

## 상태 아키텍처

서버가 상태(세션)를 가지면 사용자는 특정 서버에 종속되는데 이를 **sticky session** 이라고 부른다.
예를 들어, 사용자가 서버 A로 접속해 로그인 등 세션 정보를 인메모리에 저장했다면 다음 요청 시에도 서버 A로 접속해야 로그인 상태를 유지할 수 있다. 

이는 로드밸런서에 무리가 되며 서버를 증설하거나 줄일 때에도 어려움과 제약이 생긴다.
세션 정보를 인메모리가 아닌 데이터베이스나 캐시에 둔다면 더 이상 sticky session이 아니게 되며 무상태에 가까운 아키텍처가 된다.

### 세션, JWT 비교
즉시 무효화가 중요한 시스템에는 세션이 쓰인다. 
반면 JWT는 이미 발급된 토큰을 클라이언트가 갖고 있어 즉시 무효화하기 어렵기에 blacklist, 짧은 만료, refresh 구조가 필요하다.

세션은 세션 ID를 기반으로 서버에 위치한 세션 저장소에 세션 ID가 존재하는지를 확인해 인증을 거친다.
JWT 인증방식은 클라이언트가 보낸 토큰을 Header, Payload, Signature로 나눠 Header, Payload와 서버에 저장된 secret key를 기반으로 Signature를 생성하고 토큰에 속한 Signature과 동일한지 비교해 토큰 위조를 판별한다.


세션 로그인은 세션 ID를 쿠키로 받고 요청마다 자동 전송하고, JWT의 Access Token은 Authorization에 위치해 무상태 인증을 관리하고 Refresh Token은 HttpOnly Cookie에 위치해 로그인 상태를 관리한다.

**JWT의 문제**: 로그아웃 하더라도 클라이언트가 가진 access token의 만료시간이 남아 있다면 서버로 접속이 가능하다.
→ access token을 매우 짧게 가져가거나, refresh token을 서버에서 통제하고, redis로 추가 검증하여 문제를 상쇄시킬 수 있다.
    
---

## 무상태 아키텍처

![image.png](attachment:d84fc2cd-e1e3-4883-9aa7-bc8b5d8d71c9:image.png)

무상태 아키텍처의 상태정보는 웹서버로부터 물리적으로 분리되어 있어 서버가 자동으로 규모 확장이 가능해진다. 

세션 데이터를 저장하는 공유 저장소는 관계형 DB일 수도, Memcached/Redis 같은 캐시일 수도 NoSQL일 수도 있다 (NoSQL이 규모 확장에 간편함이 있다)